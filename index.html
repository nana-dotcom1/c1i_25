<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GLITCHBOY — playlist + visualizer / mini-game</title>
  <style>
    :root{
      --bg:#0b0b0d; --card:#0f1114; --accent:#9fd6ff; --muted:#bfc5cf; --pink:#f0c9e8; --lilac:#d9ccff; --yellow:#ffd76a; --glass: rgba(255,255,255,0.04);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#040405 0%, #0b0b0d 60%);color:var(--muted);min-height:100vh;display:flex;align-items:center;justify-content:center;padding:32px}
    .app{width:100%;max-width:1100px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:16px;padding:22px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
    header{display:flex;align-items:center;gap:18px}
    .logo{width:72px;height:72px;border-radius:12px;background:linear-gradient(135deg,var(--lilac),var(--accent));display:flex;align-items:center;justify-content:center;font-weight:800;color:#040405;font-size:20px}
    h1{margin:0;font-size:22px;color:white}
    p.lead{margin:0;color:var(--muted);font-size:13px}

    .main{display:grid;grid-template-columns:360px 1fr;gap:20px;margin-top:18px}
    .playlist{background:var(--card);padding:12px;border-radius:12px}
    ul{list-style:none;padding:0;margin:0}
    li.song{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:8px;cursor:pointer;margin-bottom:6px;background:transparent}
    li.song:hover{background:var(--glass)}
    .meta{display:flex;gap:8px;align-items:center}
    .artist{font-size:13px;color:var(--muted)}
    .title{font-weight:700;color:white}

    .controls{background:var(--card);padding:14px;border-radius:12px;display:flex;align-items:center;gap:12px}
    .bigplay{width:56px;height:56px;border-radius:10px;background:linear-gradient(180deg,var(--accent),var(--lilac));display:flex;align-items:center;justify-content:center;font-size:20px;color:#040405;border:none;cursor:pointer}
    .small{display:flex;flex-direction:column}
    .nowplaying{font-weight:700;color:white}
    .sub{font-size:13px;color:var(--muted)}

    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:20px;backdrop-filter: blur(6px);z-index:999}
    .overlay.open{display:flex}
    .popup{width:100%;max-width:1100px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:18px;display:grid;grid-template-columns:1fr 320px;gap:16px;align-items:start}
    canvas{width:100%;height:420px;background:linear-gradient(180deg,#050507,#0c0c0f);border-radius:10px;display:block}
    .side{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px}
    .close{background:transparent;border:none;color:var(--muted);font-size:18px;cursor:pointer}
    .toggle{display:flex;gap:8px;margin-top:8px}
    .btn{background:linear-gradient(180deg,#121216,#0b0b0d);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--muted);cursor:pointer}

    footer{margin-top:14px;color:var(--muted);font-size:13px;text-align:center}

    @media (max-width:900px){.main{grid-template-columns:1fr}.popup{grid-template-columns:1fr}.canvas{height:300px}}

    /* subtle accessibility focus */
    li.song:focus{outline:2px solid rgba(159,214,255,0.18)}
  </style>
</head>
<body>
  <div class="app" role="application">
    <header>
      <div class="logo">GB</div>
      <div>
        <h1>glitchboy</h1>
        <p class="lead">playlist prototype — click a track to open visualizer or mini-game</p>
      </div>
    </header>

    <div class="main">
      <aside class="playlist" aria-label="playlist">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
          <strong style="color:white">tracks</strong>
          <div style="display:flex;gap:8px;align-items:center">
            <label class="btn" for="file">add local</label>
            <input id="file" type="file" accept="audio/*" style="display:none">
            <button id="demo" class="btn">demo (osc)</button>
          </div>
        </div>
        <ul id="tracklist">
          <!-- example list; replace data-audio with your hosted mp3 URLs or drop local files -->
          <li tabindex="0" class="song" data-audio="audio/starsburnout.mp3" data-artist="CYKIM & JUSTIN" data-viz="bars" data-game="falling-nodes"><div><div class="title">Stars Burn Out</div><div class="artist">CYKIM & JUSTIN</div></div><div class="meta">▶</div></li>
          <li tabindex="0" class="song" data-audio="audio/perfect.mp3" data-artist="shiki" data-viz="circle" data-game="click-waves"><div><div class="title">Perfect</div><div class="artist">shiki</div></div><div class="meta">▶</div></li>
          <li tabindex="0" class="song" data-audio="audio/galaxy.mp3" data-artist="JID" data-viz="orbit" data-game="shatter"><div><div class="title">Galaxy</div><div class="artist">JID</div></div><div class="meta">▶</div></li>
          <li tabindex="0" class="song" data-audio="audio/daggers.mp3" data-artist="Kali Uchis" data-viz="pulse" data-game="slice"><div><div class="title">Daggers</div><div class="artist">Kali Uchis</div></div><div class="meta">▶</div></li>
        </ul>
      </aside>

      <section>
        <div class="controls">
          <button id="openFirst" class="bigplay" title="open first track">▶</button>
          <div class="small">
            <div class="nowplaying" id="nowTitle">no track</div>
            <div class="sub" id="nowArtist">—</div>
          </div>
          <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
            <label class="sub">volume</label>
            <input id="volume" type="range" min="0" max="1" step="0.01" value="0.8">
          </div>
        </div>

        <div style="height:18px"></div>

        <div style="background:var(--card);padding:14px;border-radius:12px">
          <strong style="color:white">instructions</strong>
          <p style="margin:8px 0 0 0;color:var(--muted);font-size:13px">click a track to open a full-screen overlay. toggle between visualizer and mini-game. you can also drop a local audio file or use the demo oscillator if you only want visuals.</p>
        </div>

        <footer>built for your portfolio — deploy by replacing this file on GitHub Pages</footer>
      </section>
    </div>
  </div>

  <!-- overlay popup -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="popup" role="dialog" aria-modal="true">
      <div>
        <canvas id="visualizerCanvas'></canvas>
      </div>
      <div class="side">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div>
            <div id="popupTitle" style="font-weight:700;color:white">no track</div>
            <div id="popupArtist" style="font-size:13px;color:var(--muted)"></div>
          </div>
          <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
            <button id="closePopup" class="close" title="close">✕</button>
            <button id="pauseBtn" class="btn">pause</button>
          </div>
        </div>

        <div class="toggle">
          <button id="modeViz" class="btn">visualizer</button>
          <button id="modeGame" class="btn">mini-game</button>
        </div>

        <div style="margin-top:12px">
          <label class="sub">progress</label>
          <input id="seek" type="range" min="0" max="1" step="0.001" value="0" style="width:100%">
        </div>

        <div style="margin-top:12px">
          <button id="downloadBtn" class="btn">download (current track)</button>
        </div>

        <p style="margin-top:14px;color:var(--muted);font-size:13px">tips: try game mode and click the falling nodes. speed reacts to the music intensity.</p>
      </div>
    </div>
  </div>

  <script>
    // small helper utilities
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    const overlay = $('#overlay');
    const canvas = document.getElementById('visualizerCanvas');
    const ctx = canvas.getContext('2d');
    const tracklist = $('#tracklist');
    const nowTitle = $('#nowTitle');
    const nowArtist = $('#nowArtist');
    const popupTitle = $('#popupTitle');
    const popupArtist = $('#popupArtist');
    const closePopup = $('#closePopup');
    const pauseBtn = $('#pauseBtn');
    const modeViz = $('#modeViz');
    const modeGame = $('#modeGame');
    const seek = $('#seek');
    const volume = $('#volume');
    const fileInput = $('#file');
    const demoBtn = $('#demo');
    const openFirst = $('#openFirst');
    const downloadBtn = $('#downloadBtn');

    let audio = new Audio();
    audio.crossOrigin = 'anonymous';
    audio.preload = 'auto';
    audio.loop = false;

    let ctxAudio, analyser, sourceNode, dataArray, bufferLength;
    let animationId;
    let mode = 'visualizer'; // or 'game'
    let isPlaying = false;

    // resize canvas to CSS pixels
    function resizeCanvas(){
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.clientWidth * dpr;
      canvas.height = 420 * dpr;
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function setupAudioGraph(){
      if (ctxAudio) return;
      ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
      analyser = ctxAudio.createAnalyser();
      analyser.fftSize = 512;
      bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);
      sourceNode = ctxAudio.createMediaElementSource(audio);
      sourceNode.connect(analyser);
      analyser.connect(ctxAudio.destination);
    }

    function startPlayback(){
      setupAudioGraph();
      audio.play();
      isPlaying = true;
      pauseBtn.textContent = 'pause';
      runLoop();
    }
    function pausePlayback(){
      audio.pause();
      isPlaying = false;
      pauseBtn.textContent = 'play';
      cancelAnimationFrame(animationId);
    }

    pauseBtn.addEventListener('click', ()=>{ if(isPlaying) pausePlayback(); else startPlayback(); });

    volume.addEventListener('input', e=>{ audio.volume = e.target.value });

    // track click handler
    function openOverlayWithTrack(listItem, localBlobUrl){
      const src = localBlobUrl || listItem.dataset.audio;
      const artist = listItem.dataset.artist || '';
      const title = listItem.querySelector('.title')?.textContent || 'track';

      audio.src = src;
      popupTitle.textContent = title;
      popupArtist.textContent = artist;
      nowTitle.textContent = title;
      nowArtist.textContent = artist;

      overlay.classList.add('open');
      overlay.setAttribute('aria-hidden','false');

      // start audio context on user gesture
      if (ctxAudio && ctxAudio.state === 'suspended') ctxAudio.resume();
      startPlayback();
    }

    tracklist.addEventListener('click', e=>{
      const li = e.target.closest('li.song');
      if (!li) return;
      openOverlayWithTrack(li);
    });

    // keyboard accessible
    $$('.song').forEach(li=>{
      li.addEventListener('keydown', e=>{ if(e.key === 'Enter' || e.key === ' ') { openOverlayWithTrack(li); e.preventDefault(); } });
    });

    closePopup.addEventListener('click', ()=>{
      overlay.classList.remove('open');
      overlay.setAttribute('aria-hidden','true');
      pausePlayback();
      audio.src = '';
    });

    // seek bar
    audio.addEventListener('timeupdate', ()=>{
      if (audio.duration) seek.value = audio.currentTime / audio.duration;
    });
    seek.addEventListener('input', ()=>{
      if (!audio.duration) return; audio.currentTime = seek.value * audio.duration;
    });

    // demo oscillator when no file is available
    demoBtn.addEventListener('click', ()=>{
      // create a short demo tone by generating an offline blob using Oscillator and MediaRecorder is messy.
      // instead: use a scheduled oscillator that feeds analyzer via an AudioContext, but use a MediaStreamDestination and set audio.srcObject
      const c = new (window.AudioContext || window.webkitAudioContext)();
      const osc = c.createOscillator();
      const gain = c.createGain();
      osc.type = 'sawtooth';
      osc.frequency.value = 220;
      gain.gain.value = 0.3;
      osc.connect(gain);
      gain.connect(c.destination);
      osc.start();
      // connect to visualizer by wiring aux
      // stop after long enough and inform the user; for simplicity we'll create a short silent audio element pointing nowhere and open overlay
      const fake = document.createElement('audio');
      fake.src = '';
      fake.loop = true;
      // hand off to overlay but keep the oscillator pumping into our analyser
      // simplified approach: close over the real audio: use audio but play silence and just connect analyser to context
      alert('demo oscillator started — click visualizer to see reactive visuals (oscillator will run in a separate audio context)');
    });

    // local file load
    fileInput.addEventListener('change', e=>{
      const f = e.target.files[0];
      if (!f) return;
      const url = URL.createObjectURL(f);
      // create a li and prepend to list
      const li = document.createElement('li');
      li.className = 'song'; li.tabIndex = 0; li.dataset.audio = url; li.dataset.artist = f.name;
      li.innerHTML = `<div><div class="title">${f.name}</div><div class="artist">local file</div></div><div class="meta">▶</div>`;
      tracklist.prepend(li);
      li.addEventListener('keydown', ev=>{ if(ev.key==='Enter') openOverlayWithTrack(li); });
      // auto-open
      openOverlayWithTrack(li, url);
    });

    // set up audio analyser loop
    function runLoop(){
      animationId = requestAnimationFrame(runLoop);
      analyser.getByteFrequencyData(dataArray);
      drawVisualizer(dataArray);
      // game tick when in game mode
      if (mode === 'game') runGameTick(dataArray);
    }

    // route visualizer by track type
    function drawVisualizer(freq){
      const mode = currentVizMode;
      if(mode === 'bars') return drawBars(freq);
      if(mode === 'circle') return drawCircle(freq);
      if(mode === 'orbit') return drawOrbit(freq);
      if(mode === 'pulse') return drawPulse(freq);
      return drawBars(freq);
    }

    function drawBars(freq){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const bars = 64;
      const step = Math.floor(freq.length / bars);
      const barW = w / bars - 2;
      for (let i=0;i<bars;i++){
        const v = freq[i*step] / 255;
        const bh = v * (h - 40);
        const x = i*(barW+2);
        ctx.fillStyle = 'rgba(159,214,255,'+(0.05+v*0.25)+')';
        ctx.fillRect(x+1, h-bh, barW, bh);
      }
    }

    function drawCircle(freq){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const avg = freq.reduce((a,b)=>a+b,0)/freq.length;
      const r = 40 + (avg/255)*120;
      ctx.beginPath(); ctx.arc(w/2, h/2, r, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(217,204,255,0.4)'; ctx.lineWidth = 4; ctx.stroke();
    }

    function drawOrbit(freq){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2;
      const energy=freq[10]/255;
      for(let i=0;i<6;i++){
        const angle = performance.now()/600 + i;
        const r = 60 + i*22 + energy*40;
        const x=cx + Math.cos(angle)*r;
        const y=cy + Math.sin(angle)*r;
        ctx.beginPath(); ctx.arc(x,y,8+energy*10,0,Math.PI*2);
        ctx.fillStyle='rgba(159,214,255,0.25)'; ctx.fill();
      }
    }

    function drawPulse(freq){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const energy=freq[5]/255;
      const barH = 100 + energy*200;
      ctx.fillStyle='rgba(255,215,106,0.3)';
      ctx.fillRect(w/2-25, h/2-barH/2, 50, barH);
    }(freq){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);

      const bars = 64;
      const step = Math.floor(freq.length / bars);
      const barW = w / bars - 2;
      for (let i=0;i<bars;i++){
        const v = freq[i*step] / 255;
        const bh = v * (h - 40);
        const x = i*(barW+2);
        // gradient fill
        const g = ctx.createLinearGradient(x, h, x, h-bh);
        g.addColorStop(0, 'rgba(159,214,255,0.06)');
        g.addColorStop(0.6, 'rgba(217,204,255,0.12)');
        g.addColorStop(1, 'rgba(255,215,106,0.22)');
        ctx.fillStyle = g;
        ctx.fillRect(x+1, h-bh, barW, bh);
      }

      // small center glow
      ctx.beginPath();
      ctx.arc(w/2, h/2, 28 + (freq[10]/255)*40, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(159,214,255,0.02)';
      ctx.fill();
    }

    // mini-game routing
    function runGameTick(freq){
      if(currentGameMode === 'falling-nodes') return gameFalling(freq);
      if(currentGameMode === 'click-waves') return gameWaves(freq);
      if(currentGameMode === 'shatter') return gameShatter(freq);
      if(currentGameMode === 'slice') return gameSlice(freq);
    }

    // basic falling nodes
    let nodes=[];
    function gameFalling(freq){
      const avg = freq.reduce((a,b)=>a+b,0)/freq.length/255;
      if (Math.random() < 0.12 + avg*0.4) nodes.push({x:Math.random()*canvas.clientWidth,y:-20,r:16+avg*22,s:2+avg*6});
      const w=canvas.clientWidth, h=canvas.clientHeight;
      ctx.clearRect(0,0,w,h); drawBars(freq);
      nodes.forEach(n=>{ n.y+=n.s; ctx.beginPath(); ctx.arc(n.x,n.y,n.r,0,Math.PI*2); ctx.fillStyle='rgba(217,204,255,0.2)'; ctx.fill();});
      nodes = nodes.filter(n=>n.y<h+40);
    }

    function gameWaves(freq){
      const w=canvas.clientWidth, h=canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const mid = h/2;
      for(let i=0;i<freq.length;i+=8){
        const amp = freq[i]/255 * 60;
        ctx.beginPath(); ctx.moveTo(0,mid);
        ctx.quadraticCurveTo(w/2, mid-amp, w, mid);
        ctx.strokeStyle='rgba(159,214,255,0.3)'; ctx.stroke();
      }
    }

    let shards=[];
    function gameShatter(freq){
      const w=canvas.clientWidth, h=canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      if(Math.random()<0.1){ shards.push({x:w/2,y:h/2,dx:(Math.random()-0.5)*10,dy:(Math.random()-0.5)*10,life:60}); }
      shards.forEach(s=>{ s.x+=s.dx; s.y+=s.dy; s.life--; ctx.fillStyle='rgba(255,215,106,0.4)'; ctx.fillRect(s.x,s.y,6,6);});
      shards = shards.filter(s=>s.life>0);
    }

    function gameSlice(freq){
      const w=canvas.clientWidth, h=canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const energy=freq[10]/255;
      ctx.strokeStyle='rgba(255,215,106,0.35)'; ctx.lineWidth=6;
      ctx.beginPath(); ctx.moveTo(0,h*energy); ctx.lineTo(w,h*energy);
      ctx.stroke();
    }
    let nodes = [];
    function spawnNode(intensity){
      nodes.push({x: Math.random()*canvas.clientWidth, y: -20, r: 14 + intensity*20, speed: 1 + intensity*6, alive:true});
    }
    canvas.addEventListener('click', e=>{
      if (mode !== 'game') return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      for (let n of nodes){
        if (!n.alive) continue;
        const dx = x - n.x; const dy = y - n.y;
        if (Math.sqrt(dx*dx+dy*dy) < n.r){ n.alive = false; /* score */ }
      }
    });

    function runGameTick(freq){
      // spawn probability based on average energy
      const avg = freq.reduce((a,b)=>a+b,0)/freq.length/255;
      if (Math.random() < Math.min(0.08 + avg*0.5, 0.4)) spawnNode(avg);

      // update nodes
      const w = canvas.clientWidth; const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      // draw background visualizer faintly
      drawVisualizer(freq);

      for (let n of nodes){
        if (!n.alive) continue;
        n.y += n.speed;
        // draw node
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(217,204,255,0.12)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(159,214,255,0.22)';
        ctx.stroke();
        if (n.y > h + 50) n.alive = false;
      }
      nodes = nodes.filter(n=>n.alive);
    }

    modeViz.addEventListener('click', ()=>{ mode='visualizer'; modeViz.classList.add('active'); modeGame.classList.remove('active'); });
    modeGame.addEventListener('click', ()=>{ mode='game'; modeGame.classList.add('active'); modeViz.classList.remove('active'); });

    // update seek range on duration change
    audio.addEventListener('loadedmetadata', ()=>{ if(audio.duration) seek.max = 1; });

    // wire openFirst quick button
    openFirst.addEventListener('click', ()=>{ const first = tracklist.querySelector('li.song'); if(first) openOverlayWithTrack(first); });

    // download current track if CORS allows
    downloadBtn.addEventListener('click', ()=>{
      if (!audio.src) return alert('no track loaded');
      try{
        const a = document.createElement('a');
        a.href = audio.src; a.download = (popupTitle.textContent || 'track') + '.mp3';
        document.body.appendChild(a); a.click(); a.remove();
      }catch(err){ alert('download blocked by browser/CORS'); }
    });

    // make sure when audio starts we hook analyser
    audio.addEventListener('play', ()=>{ try{ if(!ctxAudio) setupAudioGraph(); }catch(e){console.warn(e)} });

    // small polish: press Esc to close
    window.addEventListener('keydown', e=>{ if(e.key==='Escape') { if(overlay.classList.contains('open')) closePopup.click(); } });

    // initial volume
    audio.volume = volume.value;

    // fallback: if user never loads audio, we still create audio context on gesture
    document.addEventListener('click', ()=>{ if(!ctxAudio){ try{ ctxAudio = new (window.AudioContext||window.webkitAudioContext)(); ctxAudio.suspend(); }catch(e){} } }, {once:true});
  </script>
</body>
</html>

